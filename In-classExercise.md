# In-class Exercise

## 2017.03.21

An operating system is just a very complicated program. It has the job of organizing other programs on a computer, including sharing the computer's time, memory, hardware and other resources. 

Since the operating system has to interact with the hardware on a computer system, it also has to have specific knowledge of the hardware on a system. To allow operating systems to be used on a variety of computers, the concept of drivers was invented. 

Drivers are small bits of code that can be added and removed from the operating system in order to allow the operating system to talk to a particular piece of hardware. 

## 2017.04.18

When the Ebola outbreak in West Africa picked up pace in July 2014, Caitlin Rivers started to collect data on the people affected. Rivers, then a PhD student in computational epidemiology, wanted to model the outbreak’s spread. So every day she downloaded PDF updates released by the ministries of health of the virus-stricken countries, and converted the numbers into computer-readable tables. 

Rather than keeping these files to herself, she posted them to GitHub.com, a hugely popular website for collaborative work on software code. Rivers thought the postings might attract those interested in up-to-date information from the Ebola outbreak. “I figured if I needed it, other people would, too,” she says.

## 2017.05.12

Scientists writing software need to write code that both executes correctly and can be easily read and understood by other programmers (especially the author's future self). 

If software cannot be easily read and understood, it is much more difficult to know that it is actually doing what it is intended to do. 

To be productive, software developers must therefore take several aspects of human cognition into account: in particular, that human working memory is limited, human pattern matching abilities are finely tuned, and human attention span is short.

## 2017.05.16

Today’s computers and software are so complex that even experts  find it hard to predict which parts of any particular program will be performance bottlenecks. 

The most productive way to make code fast is therefore to make it work correctly, determine whether it’s actually worth speeding it up, and — in those cases where it is — to use a profiler to identify bottlenecks .

This strategy also has interesting implications for choice of programming language. 

Since faster, lower level, languages require more lines of code to accomplish the same task, scientists are most productive when they write code in the highest-level language possible , and shift to low level languages like C and Fortran only when they are sure the performance boost is needed.

Using higher-level languages also helps program comprehensibility .
